В этом проекте вы реализуете различные типы контейнеров стандартной библиотеки шаблонов C ++.
Для каждого контейнера включите файлы классов с соответствующими именами.


lhs и rhs - левая сторона и правая сторона.Они используются в качестве входных данных для функций оператора над погрузчиком. Левую сторону сравнивают с правой.
Функции оператора Overloader меняют способ работы символов оператора.

limits — заголовочный файл стандартной библиотеки общего назначения языка программирования Си, который включает определения характеристик общих типов переменных. Значения зависят от специфики реализации, но могут быть не ниже диапазона, определенного для конечного значения в удобной реализации Си.
<cstdio> - Включает заголовок стандартной библиотеки C <stdio.h> и добавляет связанные имена в std пространство имен.
Namespace в переводе означает пространство имен. Используется для логической группировки классов, функций и переменных. ... Основная задача пространств имен состоит в том, чтобы избежать коллизий имен в глобальном пространстве имен.
Тип ptrdiff_t - базовый знаковый целочисленный тип языка Си/Си++. Размер типа выбирается таким образом, чтобы в него можно было записать максимальный размер теоретически возможного массива любого типа. На 32-битной системе ptrdiff_t будет занимать 32-бита, на 64-битной - 64-бита.

Могут быть вопросы по:

Рализовано все в хедере и это правильно тк все классы контейнерные, то я использую шаблоны. А шаблоны можно реализовывать только в хедере

• Для перегрузок, не являющихся членами, разрешено ключевое слово friend.
Дружественные функции - это функции, которые не являются членами класса, однако имеют доступ к его закрытым членам - переменным и функциям, которые имеют спецификатор private.

LIST:

Нужно работать с С++98, но есть одна вещь (условное использование функций) которую я реализовала в структуре List_Iterator

Основа = это итераторы, которые включают в себя двунаправленный, константный и обратный
Нужно описать сам итератор, для того чтобы я могла перемещаться по своему контейнеру 

Также использую аллокатор, похож на малок в си 
Тк используется совсем низкоуровневая память, те даже не байты а ячейки, то мы используем аллигатор 


MAP(карта)

По суди это отсортированный по хешам массив 
Разница между лист и мат том что в листе мы обращаемся непосредственно к элементу, те осуществляем поиск либо по номеру этого элемента (в контейнере) либо по значению, а в мапе используется такое понятие как ключ-значение, те мы например добавили несколько слов и искаться они будут по ключу 

Ключом может быть все что угодна. От обычной переменной до класса.
При добавлении нового элемента контейнер будет отсортирован по возрастанию.


lower_bound() возвращает итератор, указывающий на первую позицию в отсортированной последовательности, ограниченной диапазоном [first,last), в которую можно вставить значение value, не нарушая упорядоченности. В этой позиции находится значение, большее либо равное value

upper_bound() возвращает итератор, указывающий на последнюю позицию в отсортированной последовательности [first,last), в которую еще можно вставить значение value, не нарушая упорядоченности. Значения всех элементов, начиная с этой позиции и далее, будут больше, чем value

STACK

Стек (англ. stack — стопка; читается стэк) — абстрактный тип данных, представляющий собой список элементов, организованных по принципу LIFO (англ. last in — first out, «последним пришёл — первым вышел»).
Стек состоит из ячеек(в примере — это книги), которые представлены в виде структуры, содержащей какие-либо данные и указатель типа данной структуры
В стеке нет индексов как в массиве, а значит вы не можете обратиться к определенному элементу. Все потому что, стек построен на связных списках.


QUEUE
Написано с помощью (deque) — двусторонней очереди. 

Очередь(Queue) — это структура данных (как было сказано выше), которая построена по принципу LILO (last in — last out: последним пришел — последним вышел). В C++ уже есть готовый STL контейнер — queue.

В очереди, если вы добавите элемент, который вошел самый первый, то он выйдет тоже самым первым. Получается, если вы добавите 4 элемента, то первый добавленный элемент выйдет первым.
Чтобы понять принцип работы очереди вы можете представить себе магазинную очередь. И вы стоите посреди нее, чтобы вы оказались напротив кассы, сначала понадобится всех впереди стоящих людей обслужить. А вот для последнего человека в очереди нужно, чтобы кассир обслужил всех людей кроме него самого.

VECTOR

Он как массив
Используем итераторы 
Лежат элементы как в связном списке

std::vector (или просто «вектор») — это тот же динамический массив, но который может сам управлять выделенной себе памятью. Это означает, что вы можете создавать массивы, длина которых задается во время выполнения, без использования операторов new и delete (явного указания выделения и освобождения памяти)
